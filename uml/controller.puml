@startuml controller
hide circle
skinparam classFontStyle bold
skinparam groupInheritance 1
set separator ::
skinparam classAttributeIconSize 12

' TODO sistemare tipi

' format unfinished games: list form
' 1 - game_id - num_players - player_name_0, .. , player_name_num_players-1.

package Controller{

    package Client{

        abstract ClientConnection{
            {method} # sendMessage(Message) : void
            {method} # close() : void
        }

        ClientConnection^..ClientRMIServerStub
        class ClientRMIServerStub{
            TODO
            {method} + sendMessage(Message) : void
            {method} + close() : void
        }

        ClientConnection^..ClientSocket
        class ClientSocket{
            TODO
            {method} + sendMessage(Message) : void
            {method} + close() : void
        }

        interface iClientGameController <<interface>> {
            {method} + throwException(Exception) : void 
            {method} + updateTurn(int, PlayerColor) : void 
            {method} + showCard(int) : void 
            {method} + updatePhase(GameState) : void 
            {method} + updateShip(PlayerColor, iSpaceShip) : void 
            {method} + updateShipValidationResult(boolean, VerifyResult[]) : void 
            {method} + moveOnBoard(PlayerColor, int) : void 
            {method} + pauseGame() : void 
            {method} + endGame() : void 
            {method} + ping() : void 
        }

        iClientGameController^--ClientGameController
        ClientConnection<-*ClientGameController
        class ClientGameController{
            {field} - model : ModelView
            {field} - state : GameState
            {field} - server : ClientConnection
            {field} - listener : ViewListener
            {method} + throwException(Exception) : void 
            {method} + updateTurn(int, PlayerColor) : void 
            {method} + showCard(int) : void 
            {method} + updatePhase(GameState) : void 
            {method} + updateShip(PlayerColor, iSpaceShip) : void 
            {method} + updateShipValidationResult(boolean, VerifyResult[]) : void 
            {method} + moveOnBoard(PlayerColor, int) : void 
            {method} + pauseGame() : void 
            {method} + endGame() : void 
            {method} + ping() : void 
        }

    }

    package Server{

        class ClientDescriptor{
            {field} - username: String
            {field} - color : PlayerColor
            {field} - connection : Connection
            {field} - disconnected : boolean
            {method} + getUsername() : String
            {method} + getColor() : PlayerColor
            {method} + getDisconnected() : boolean
            {method} + sendMessage(ClientMessage m) : void
        }

        abstract Connection {
            {method} # sendMessage(Message) : void
            {method} # close() : void
        }

        class RmiConnection {
            TODO
            {method} + sendMessage(Message) : void
            {method} + close() : void
        }

        class SocketConnection {
            TODO
            {method} + sendMessage(Message) : void
            {method} + close() : void
        }

        class Server <<singleton>>{
            {field} - instance : Server
            {method} + run() : void
            {method} + accept(RmiConnection) : ClientRMIServerStub
            {method} + getInstance() : Server  <<static>>
        }

        class ModelInstance{
            {field} - player_ships : iSpaceShip[]
            {field} - planche : iPlanche
            {field} - board : iCommonBoard
            {field} - card_piles : iCards[]
            {method} + getShip(PlayerColor) : iSpaceShip
            {method} + getPlanche() : iPlanche 
            {method} + getBoard() : iCommonBoard
            {method} + getCard(int) : iCard
        }

        class ServerController{
            {field} - player_list : ClientDescriptor[]
            {field} - game : ModelInstance
            {field} - waiting : boolean
            {method} + connect() : void
            {method} + disconnect() : void
            {method} + sendContinue() : void
            {method} + putComponent(ClientDescriptor, ShipCoords, ComponentRotation, int) : void
            {method} + takeComponent(ClientDescriptor) : void
            {method} + takeDiscarded(ClientDescriptor, int) : void
            {method} + discardComponent(ClientDescriptor, int component_id) : void
            {method} + toggleHourglass(ClientDescriptor) : void
            {method} + removeComponent(ClientDescriptor, ShipCoords) : void
            {method} + setCrewType(ClientDescriptor, ShipCoords, AlienType) : void
            {method} + setNewShipCenter(ClientDescriptor, ShipCoords) : void
            {method} + turnOn(ClientDescriptor, ShipCoords, ShipCoords) : void
            {method} + removeCrew(ClientDescriptor, ShipCoords[]) : void
            {method} + takeCargo(ClientDescriptor, ShipmentType, ShipCoords) : void
            {method} + askUpdateState(ClientDescriptor) : void
            {method} + progressTurn(ClientDescriptor) : void
            {method} + ping(ClientDescriptor) : void
        }

        abstract GameState <<abstract>> {
            {field} - match : MatchController
            {field} - model : ModelInstance
            {field} - plist : ClientDescriptor[]
            {method} + action(ModelInstance instance) : void
            {method} + finished() : boolean
            {method} + transition() : void 
            {method} + ping(ClientDescriptor) : void
        }

        class ConstructionState{
            {field} - match : MatchController
            {field} - model : ModelInstance
            {field} - plist : ClientDescriptor[]
            {method} + action(ModelInstance instance) : void
            {method} + finished() : boolean
            {method} + transition() : void 
            {method} + putComponent(ClientDescriptor, ShipCoords, ComponentRotation, int) : void
            {method} + takeComponent(ClientDescriptor) : void
            {method} + takeDiscarded(ClientDescriptor, int) : void
            {method} + discardComponent(ClientDescriptor, int component_id) : void
            {method} + toggleHourglass(ClientDescriptor) : void
        }

        class VerifyState{
            {field} - match : MatchController
            {field} - model : ModelInstance
            {field} - plist : ClientDescriptor[]
            {method} + action(ModelInstance instance) : void
            {method} + finished() : boolean
            {method} + transition() : void 
            {method} + removeComponent(ClientDescriptor, ShipCoords) : void
            {method} + setCrewType(ClientDescriptor, ShipCoords, AlienType) : void
        }
        
        class VoyageState{
            {field} - match : MatchController
            {field} - model : ModelInstance
            {field} - plist : ClientDescriptor[]
            {method} + action(ModelInstance instance) : void
            {method} + finished() : boolean
            {method} + transition() : void 
            {method} + setNewShipCenter(ClientDescriptor, ShipCoords) : void
            {method} + turnOn(ClientDescriptor, ShipCoords, ShipCoords) : void
            {method} + removeCrew(ClientDescriptor, ShipCoords[]) : void
            {method} + takeCargo(ClientDescriptor, ShipmentType, ShipCoords) : void
            {method} + askUpdateState(ClientDescriptor) : void
            {method} + progressTurn(ClientDescriptor) : void
        }

        class LeaderboardState{
            {field} - match : MatchController
            {field} - model : ModelInstance
            {field} - plist : ClientDescriptor[]
            {method} + action(ModelInstance instance) : void
            {method} + finished() : boolean
            {method} + transition() : void 
        }

    }

    package Message{

        interface Message <<interface, serializable>> {
        }
        Message^--ServerMessage::ServerMessage
        package ServerMessage{
            abstract ServerMessage <<abstract>> {

            }
        }
        Message^--ClientMessage::ClientMessage
        package ClientMessage {
            abstract ClientMessage <<abstract>> {

            }
        }
        
    }

}
@enduml


